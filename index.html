<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Raken 真實鞭炮 Overlay V3.0</title>
    <script src="https://cdn.jsdelivr.net/npm/comfy.js@1.1.6/dist/comfy.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Microsoft JhengHei", sans-serif; background: transparent; }
        
        #scene-container { 
            width: 100vw; height: 100vh; 
            position: relative; 
            display: flex; justify-content: center; align-items: flex-start; /* 改為靠上對齊 */
            padding-top: 50px; /* 預留上方空間 */
        }

        /* SVG 容器 */
        #svg-wrapper {
            height: 75vh; /* 鞭炮大小 */
            transform-origin: top center; /* 擺動支點在上方 */
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.3));
            position: relative;
            z-index: 10;
        }

        /* 1. 微風擺動動畫 (常駐) */
        .sway-anim {
            animation: sway 3s ease-in-out infinite alternate;
        }
        @keyframes sway {
            0% { transform: rotate(-2deg); }
            100% { transform: rotate(2deg); }
        }

        /* 4. 新鞭炮掉落動畫 */
        @keyframes dropIn {
            0% { transform: translateY(-100vh); }
            60% { transform: translateY(20px); }
            80% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }
        .drop-anim {
            animation: dropIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        /* 爆炸閃光 */
        .boom {
            position: absolute;
            width: 100px; height: 100px;
            background: radial-gradient(circle, #fff 30%, #ffcc00 60%, transparent 80%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 50;
            mix-blend-mode: screen;
        }
        @keyframes explodeAnim {
            0% { transform: scale(0.1); opacity: 1; }
            50% { opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* 6. 炸裂式文字特效 */
        #result-text {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            opacity: 0;
            z-index: 100;
            pointer-events: none;
        }

        .lucky-text-group {
            display: inline-block;
            transform: scale(0); /* 初始縮小 */
        }

        /* 文字炸出來的動畫 */
        .text-explode {
            animation: textPop 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes textPop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; text-shadow: 0 0 50px red; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; text-shadow: 0 0 10px gold; }
        }

        .user-label {
            font-size: 32px; color: #fff; font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 10px;
            display: block;
        }

        .quote-box {
            font-size: 56px; font-weight: 900; 
            color: #d90404;
            background: linear-gradient(to bottom, #fff, #f0f0f0);
            padding: 20px 40px;
            border-radius: 15px;
            border: 5px solid #ffd700;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(255, 215, 0, 0.5);
            display: inline-block;
        }

        /* 震動特效 (爆炸時用) */
        .shaking { animation: shake 0.05s infinite; }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            25% { transform: translate(-1px, -2px) rotate(-1deg); }
            50% { transform: translate(-2px, 0px) rotate(1deg); }
            75% { transform: translate(2px, 1px) rotate(0deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
    </style>
</head>
<body onclick="testEffect()"> 

    <div id="scene-container">
        <div id="svg-wrapper" class="sway-anim"></div>
        
        <div id="result-text">
            <div class="lucky-text-group" id="text-anim-target">
                <div class="user-label" id="u-name"></div>
                <div class="quote-box" id="q-text"></div>
            </div>
        </div>
    </div>

<script>
    // --- 設定區 ---
    const params = new URLSearchParams(window.location.search);
    const channel = params.get('channel') || 'rakenluck111';
    const targetReward = params.get('reward') || "放鞭炮";

    const quotes = [
        "垃圾桶裡都是寶藏！",
        "剪輯速度突破天際！",
        "所有霉運都被炸飛啦！",
        "浣熊尾巴又順又亮！",
        "紅紅火火大吉大利！",
        "金幣滿滿進帳不停！",
        "出門走路都撿到錢！",
        "單抽出奇蹟，金光閃閃！"
    ];

    // --- 變數區 ---
    let effectQueue = [];
    let isPlaying = false;
    let svgContent = null; 
    let originalPathsDisplay = new Map(); // 用來記錄原始路徑狀態，以便重置

    // 1. 載入 SVG
    fetch('./firecracker.svg')
        .then(response => response.text())
        .then(data => {
            const wrapper = document.getElementById('svg-wrapper');
            wrapper.innerHTML = data;
            svgContent = data; // 備份原始字串
            console.log("SVG 載入並顯示完成");
        })
        .catch(err => console.error("SVG 載入失敗", err));

    // 2. Twitch 監聽
    if(channel) {
        ComfyJS.onRewardRedemption = (user, reward) => {
            if (reward === targetReward) {
                effectQueue.push({ user: user });
                processQueue();
            }
        };
        ComfyJS.Init(channel);
    }

    function processQueue() {
        if (!isPlaying && effectQueue.length > 0 && svgContent) {
            const next = effectQueue.shift();
            startSequence(next.user);
        }
    }

    // --- 核心邏輯 ---
    function startSequence(user) {
        isPlaying = true;
        const wrapper = document.getElementById('svg-wrapper');
        
        // 1. 停止擺動，開始準備爆炸
        wrapper.classList.remove('sway-anim'); 
        wrapper.classList.add('shaking'); // 加入劇烈震動

        // 2. 篩選要炸掉的路徑
        const paths = Array.from(wrapper.querySelectorAll('path'));
        const svgRect = wrapper.querySelector('svg').getBoundingClientRect();
        
        // 設定保留區 (頂部 15% 福, 底部 15% 流蘇)
        const topSafeZone = svgRect.top + (svgRect.height * 0.15);
        const bottomSafeZone = svgRect.bottom - (svgRect.height * 0.15);

        let targets = [];

        paths.forEach(p => {
            const rect = p.getBoundingClientRect();
            const fill = (p.getAttribute('fill') || "").toUpperCase();
            
            // 判斷位置：是否在中間區域 (避開福跟流蘇)
            const isInMiddle = (rect.top > topSafeZone) && (rect.bottom < bottomSafeZone);

            // 判斷顏色：紅色系 或 金色系 (包含原本漏掉的金邊)
            // 排除黑色 (#191818 繩子)
            const isRed = fill.includes('#EA0502') || fill.includes('#FB2F10') || fill.includes('#C60000') || fill.includes('#B30000') || fill.includes('URL');
            const isGold = fill.includes('#FFDC4F') || fill.includes('#FBA02F') || fill.includes('#FECA3E') || fill.includes('#FD9926');
            const isBlack = fill.includes('#191818') || fill.includes('#6F0706'); // 繩子顏色

            if (isInMiddle && (isRed || isGold) && !isBlack) {
                targets.push({ el: p, y: rect.top, x: rect.left + rect.width/2 });
            }
        });

        // 3. 排序：由下往上炸 (Y 軸大的在下面)
        targets.sort((a, b) => b.y - a.y);

        // 4. 開始引爆迴圈
        let i = 0;
        const speed = 30; // 爆炸間隔 (毫秒)
        
        const boomInterval = setInterval(() => {
            if (i >= targets.length) {
                clearInterval(boomInterval);
                showResult(user); // 炸完顯示文字
                return;
            }

            // 處理當前鞭炮 (如果是紅色跟金色一組，可能會同時炸)
            // 簡單處理：每次炸一個 SVG Path
            const t = targets[i];
            
            // 隱藏該部件
            t.el.style.visibility = 'hidden';
            
            // 產生爆炸光效
            createBoom(t.x, t.y + 10); // 微調 Y 座標

            i++;
        }, speed);
    }

    function createBoom(x, y) {
        const boom = document.createElement('div');
        boom.className = 'boom';
        // 隨機位置微調，增加自然感
        const offsetX = (Math.random() - 0.5) * 40;
        const offsetY = (Math.random() - 0.5) * 40;
        boom.style.left = (x - 50 + offsetX) + 'px'; 
        boom.style.top = (y - 50 + offsetY) + 'px';
        boom.style.animation = "explodeAnim 0.3s ease-out forwards";
        document.getElementById('scene-container').appendChild(boom);
        setTimeout(() => boom.remove(), 300);
    }

    function showResult(user) {
        const wrapper = document.getElementById('svg-wrapper');
        const textGroup = document.getElementById('text-anim-target');
        const textContainer = document.getElementById('result-text');
        
        wrapper.classList.remove('shaking'); // 停止震動

        // 設定文字內容
        const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
        document.getElementById('u-name').innerText = `祝福 ${user}`;
        document.getElementById('q-text').innerText = randomQuote;
        
        // 6. 文字炸裂特效
        textContainer.style.opacity = 1;
        textGroup.classList.remove('text-explode'); // 重置動畫
        void textGroup.offsetWidth; // 強制重繪
        textGroup.classList.add('text-explode'); // 播放動畫

        // 4秒後重置
        setTimeout(() => {
            resetScene();
        }, 4000);
    }

    function resetScene() {
        const wrapper = document.getElementById('svg-wrapper');
        const textContainer = document.getElementById('result-text');

        // 文字消失
        textContainer.style.transition = "opacity 0.5s";
        textContainer.style.opacity = 0;

        // 4. 掉落一個新的鞭炮 (視覺上)
        // 實際上我們是把舊的鞭炮復原，然後播放掉落動畫
        
        setTimeout(() => {
            // 恢復所有隱藏的路徑
            const paths = wrapper.querySelectorAll('path');
            paths.forEach(p => p.style.visibility = 'visible');

            // 播放掉落動畫
            wrapper.classList.remove('sway-anim');
            wrapper.classList.remove('drop-anim');
            void wrapper.offsetWidth; // 強制重繪
            wrapper.classList.add('drop-anim');

            // 等掉落完畢，恢復擺動
            setTimeout(() => {
                wrapper.classList.add('sway-anim');
                isPlaying = false;
                processQueue();
            }, 1000); // 掉落動畫約 1 秒
        }, 500);
    }

    function testEffect() {
        if(!svgContent) { alert("SVG 尚未載入"); return; }
        effectQueue.push({ user: "測試小浣熊" });
        processQueue();
    }
</script>
</body>
</html>
