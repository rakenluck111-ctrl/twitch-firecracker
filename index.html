<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Raken 捲軸鞭炮 V4.0</title>
    <script src="https://cdn.jsdelivr.net/npm/comfy.js@1.1.6/dist/comfy.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Microsoft JhengHei", "Heiti TC", sans-serif; background: transparent; }
        
        #scene-container { 
            width: 100vw; height: 100vh; 
            position: relative; 
            display: flex; justify-content: center; align-items: flex-start;
            padding-top: 20px;
        }

        /* 1. 擺動層 (負責持續隨風飄動) */
        #sway-wrapper {
            transform-origin: top center;
            animation: sway 2.5s ease-in-out infinite alternate;
        }
        @keyframes sway {
            0% { transform: rotate(-3deg); }
            100% { transform: rotate(3deg); }
        }

        /* 2. 震動層 (負責爆炸時的劇烈震動) */
        #shake-wrapper {
            position: relative;
            /* 震動動畫會透過 JS class 加入 */
        }

        /* SVG 本體 */
        #svg-content {
            height: 75vh; 
            filter: drop-shadow(5px 5px 5px rgba(0,0,0,0.5));
            position: relative;
            z-index: 20; /* 確保在捲軸前面 */
        }

        /* 3. 祝福捲軸 (類似圖二) */
        #scroll-banner {
            position: absolute;
            top: 20%; /* 大約在福字的下方 */
            left: 50%;
            transform: translateX(-50%);
            width: 180px; /* 捲軸寬度 */
            height: 0; /* 初始捲起 */
            background: linear-gradient(to bottom, #d90000, #ff2222);
            border: 2px solid #ffd700;
            border-top: none;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            overflow: hidden;
            z-index: 10; /* 在鞭炮後面，但在背景前面 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: height 0.8s cubic-bezier(0.25, 1, 0.5, 1);
        }

        /* 捲軸內的文字 */
        .scroll-text {
            writing-mode: vertical-rl; /* 直式書寫 */
            font-size: 36px;
            font-weight: 900;
            color: #fff; /* 金字 */
            text-shadow: 1px 1px 0 #000;
            letter-spacing: 5px;
            opacity: 0; /* 捲開後才顯示 */
            transition: opacity 0.5s delay 0.3s;
            white-space: nowrap;
            padding: 20px 0;
        }
        
        .user-name {
            writing-mode: horizontal-tb; /* 名字橫寫在最上面 */
            font-size: 18px;
            color: #ffd700;
            margin-bottom: 10px;
            text-align: center;
            width: 100%;
            border-bottom: 1px dashed rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }

        /* 4. 掉落動畫 (重置用) */
        @keyframes dropIn {
            0% { transform: translateY(-120vh); }
            60% { transform: translateY(30px); }
            80% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }
        .drop-anim { animation: dropIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

        /* 5. 爆炸光效 */
        .boom {
            position: absolute;
            width: 120px; height: 120px;
            background: radial-gradient(circle, #fff 10%, #ffaa00 40%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 50;
            mix-blend-mode: screen;
        }
        @keyframes explodeAnim {
            0% { transform: scale(0.2); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* 震動 Keyframes */
        .shaking { animation: shake 0.05s infinite; }
        @keyframes shake {
            0% { transform: translate(2px, 2px) rotate(0deg); }
            50% { transform: translate(-2px, -2px) rotate(-1deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
    </style>
</head>
<body onclick="testEffect()"> 

    <div id="scene-container">
        <div id="sway-wrapper">
            <div id="shake-wrapper">
                
                <div id="svg-content"></div>

                <div id="scroll-banner">
                    <div class="user-name" id="u-name"></div>
                    <div class="scroll-text" id="q-text"></div>
                </div>

            </div>
        </div>
    </div>

<script>
    // --- 1. 參數設定 ---
    const params = new URLSearchParams(window.location.search);
    const channel = params.get('channel'); // 必填
    const targetReward = params.get('reward') || "放鞭炮";

    const quotes = [
        "垃圾桶裡都是寶藏",
        "剪輯速度突破天際",
        "所有霉運都被炸飛",
        "浣熊尾巴又順又亮",
        "紅紅火火大吉大利",
        "金幣滿滿進帳不停",
        "出門走路都撿到錢",
        "單抽出奇蹟金光閃"
    ];

    let effectQueue = [];
    let isPlaying = false;
    let svgRawData = null;

    // --- 2. 載入 SVG ---
    fetch('./firecracker.svg')
        .then(res => res.text())
        .then(data => {
            document.getElementById('svg-content').innerHTML = data;
            svgRawData = data;
            console.log("SVG 載入成功");
        })
        .catch(err => console.error("SVG 載入失敗: ", err));

    // --- 3. Twitch 連線 ---
    if (channel) {
        ComfyJS.onRewardRedemption = (user, reward, cost, message) => {
            console.log(`收到獎勵兌換: ${reward} 由 ${user}`); // Debug用
            if (reward === targetReward) {
                effectQueue.push({ user: user });
                processQueue();
            }
        };
        ComfyJS.Init(channel);
        console.log(`正在監聽頻道: ${channel} 的獎勵: ${targetReward}`);
    } else {
        // 如果沒有頻道參數，顯示提示
        console.warn("未設定頻道，請在網址後加上 ?channel=你的ID");
    }

    function processQueue() {
        if (!isPlaying && effectQueue.length > 0 && svgRawData) {
            const next = effectQueue.shift();
            startBlast(next.user);
        }
    }

    // --- 4. 核心動畫邏輯 ---
    function startBlast(user) {
        isPlaying = true;
        const svgDiv = document.getElementById('svg-content');
        const shakeDiv = document.getElementById('shake-wrapper');
        const scrollDiv = document.getElementById('scroll-banner');
        
        // 重置捲軸
        scrollDiv.style.height = '0';
        scrollDiv.querySelector('.scroll-text').style.opacity = '0';

        // 開始劇烈震動
        shakeDiv.classList.add('shaking');

        // 尋找爆炸目標
        // 優先找 ID="body" 的群組，如果沒有，就用舊邏輯(座標判斷)當備案
        let targets = [];
        const bodyGroup = svgDiv.querySelector('#body');
        
        if (bodyGroup) {
            // 策略 A: 有做好分組 (推薦!)
            // 取得 body 內所有的 path, circle, rect 等元素
            targets = Array.from(bodyGroup.querySelectorAll('*')).filter(el => 
                ['path', 'rect', 'circle', 'polygon'].includes(el.tagName)
            );
        } else {
            // 策略 B: 沒分組 (舊邏輯備案)
            console.log("未偵測到 #body 群組，使用座標判定模式");
            const allPaths = Array.from(svgDiv.querySelectorAll('path'));
            const svgRect = svgDiv.getBoundingClientRect();
            // 簡單暴力：炸掉中間 60% 的所有東西
            const topLimit = svgRect.top + (svgRect.height * 0.2);
            const bottomLimit = svgRect.bottom - (svgRect.height * 0.2);
            
            targets = allPaths.filter(p => {
                const r = p.getBoundingClientRect();
                return r.top > topLimit && r.bottom < bottomLimit;
            });
        }

        // 排序：由下往上炸
        targets.sort((a, b) => b.getBoundingClientRect().top - a.getBoundingClientRect().top);

        let i = 0;
        // 加快速度：原本 30ms -> 現在 15ms
        const interval = setInterval(() => {
            if (i >= targets.length) {
                clearInterval(interval);
                dropScroll(user); // 炸完放捲軸
                return;
            }

            const el = targets[i];
            const rect = el.getBoundingClientRect();
            
            // 隱藏該零件
            el.style.visibility = 'hidden';
            
            // 產生火光 (隨機偏移)
            createBoom(rect.left + rect.width/2, rect.top + rect.height/2);

            i++;
            // 為了讓速度更快，每次迴圈多炸一個
            if (i < targets.length) {
                targets[i].style.visibility = 'hidden';
                i++;
            }

        }, 15);
    }

    function createBoom(x, y) {
        const boom = document.createElement('div');
        boom.className = 'boom';
        const offsetX = (Math.random() - 0.5) * 60;
        const offsetY = (Math.random() - 0.5) * 60;
        boom.style.left = (x - 60 + offsetX) + 'px'; // 修正中心點
        boom.style.top = (y - 60 + offsetY) + 'px';
        boom.style.animation = "explodeAnim 0.2s ease-out forwards"; // 動畫加速
        document.getElementById('scene-container').appendChild(boom);
        setTimeout(() => boom.remove(), 200);
    }

    // --- 5. 捲軸掉落 ---
    function dropScroll(user) {
        const shakeDiv = document.getElementById('shake-wrapper');
        const scrollDiv = document.getElementById('scroll-banner');
        
        shakeDiv.classList.remove('shaking'); // 停止震動

        // 設定文字
        const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
        document.getElementById('u-name').innerText = user;
        document.getElementById('q-text').innerText = randomQuote;

        // 展開捲軸 (類似彩球打開)
        scrollDiv.style.height = '450px'; // 捲軸長度
        scrollDiv.querySelector('.scroll-text').style.opacity = '1';

        // 停留 4 秒後重置
        setTimeout(() => {
            resetScene();
        }, 4000);
    }

    // --- 6. 重置場景 (掉落新鞭炮) ---
    function resetScene() {
        const scrollDiv = document.getElementById('scroll-banner');
        const svgWrapper = document.getElementById('sway-wrapper'); // 整個擺動層一起掉落
        
        // 收起捲軸
        scrollDiv.style.height = '0';
        scrollDiv.querySelector('.scroll-text').style.opacity = '0';

        setTimeout(() => {
            // 重新填入 SVG (恢復那些被 hidden 的鞭炮)
            document.getElementById('svg-content').innerHTML = svgRawData;
            
            // 播放掉落動畫 (先移除擺動，掉下來後再加回去)
            svgWrapper.style.animation = 'none'; // 暫停擺動
            svgWrapper.classList.remove('drop-anim');
            void svgWrapper.offsetWidth; // 觸發重繪
            svgWrapper.classList.add('drop-anim'); // 執行掉落

            // 掉落結束後，恢復擺動
            setTimeout(() => {
                svgWrapper.style.animation = 'sway 2.5s ease-in-out infinite alternate';
                isPlaying = false;
                processQueue();
            }, 800); 
        }, 500);
    }

    function testEffect() {
        if(!svgRawData) return alert("SVG 未載入");
        effectQueue.push({ user: "測試小夥伴" });
        processQueue();
    }
</script>
</body>
</html>
